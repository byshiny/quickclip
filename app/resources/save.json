{
  "comment": "I'm trying to keep format consistent, so I'm going to have",
  "circularBuffer": [
    "https://github.com/WilixLead/iohook/issues/96",
    "var processChild = require(\"child_process\");\nvar pidTrees = require(\"pidtree\");\nlet childProcess = null;\nlet pidGroup = [];\nlet mainPid = null;\nsetInterval(async () => {\n  if (mainPid) {\n    pidGroup = [...(await pidTrees(mainPid, { root: true }))];\n    pidGroup = [...new Set(pidGroup)].sort();\n    console.log(\"all pid: \", pidGroup);\n    console.log(\"mainPid: \", mainPid);\n    pidGroup.forEach(async pid => {\n      if (pid >= mainPid) {\n        await processChild.exec(`kill -9 ${pid};`);\n      }\n    });\n    pidGroup = [];\n  }\n  setTimeout(() => {\n    childProcess = processChild.exec(\"npm run z\");\n    mainPid = childProcess.pid;\n    console.log(process.pid);\n  }, 5000);\n}, 15000);",
    "  ('Event key code' + event.keycode)\n",
    "  ('Event key code' + event.keycode)\n",
    "'use strict'\n\n/*\n\nSTEPS:\n\n1. Need to go get that circular buffer to store all values\n2. Extenralize configuration keys or different platforms\n3. Flow for adding the event back in\n*/\n/* GLOBAL Parameters\n */\n// //log.info(process.version)\n// remove hard code\n\nconst COPY_BUFFER_COUNT = 10\nconst COPY_BUFFER_TIME = 500 // this is in milliseconds\nconst COPY_MOUSE_BUFFER_SIZE = 10\nconst COPY_MOUSE_BUTTON_ACTIVATION_TIME = 3000\nconst COPY_MOUSE_BUTTON_ACTIVATION_CHECK_INTERVAL = 200\n// ok technically this needs a mutex - that check...\n\nconst COPY_MOUSE_CYCLE_INTERVAL = 1100\nconst COPY_MOUSE_ACTIVATION_CHECK_COUNT = 4\nconst MOUSE_HOLD_COUNT = 50\nconst OS = process.platform\n\nconst MOUSE_CHECK_TIME = 40\nconst MOUSE_ACCUM_CAP = 80 // at 40 seconds, must reach a cap of 80\nconst PASTE_DELAY = 50\nconst MOUSE_UP_COUNT = 5\nvar mouseDownAccum = 0 /// this is pretty much a accumilator or a counting queue\n// OK, all of this needs to be converted to OO\nvar mouseUpAccum = MOUSE_UP_COUNT\n\nvar pasteStarted = false\nvar lastPressTime = new Date()\n\nvar copyMouseItemIdx = 0\nvar copyTimePassed = 0\nvar copyMouseInterval = null\nvar copyMouseIntervalStack = []\nvar currentEvent = null\nvar bufferCycling = false\nvar saveWindowHiding = false\nvar showOrHideShowWindow = true\nconst SHORTCUT_KEY_LIMIT = 10\nconst ioHook = require('iohook')\nconst {\n  app,\n  BrowserWindow,\n  ipcMain,\n  globalShortcut,\n  clipboard,\n  dialog,\n  Menu\n} = require('electron')\n\nconst configuration = require('./configuration')\nconst stateSaver = require('./stateSaver')\nconst log = require('electron-log')\n// //log.transports.console.level = 'warn';\nvar robot = require('robotjs')\nconst path = require('path')\n\n// for mouse holding\nvar CircularBuffer = require('circular-buffer')\nvar keyMapper = require('./keyMapper')\n// TODO: Need to decide how to refactor this... group into one object???\nvar textBufferTimer = new Array(COPY_BUFFER_COUNT)\nvar textBufferChecker = new Array(COPY_BUFFER_COUNT)\nvar textBufferFired = new Array(COPY_BUFFER_COUNT)\nvar textBufferContent = new Array(COPY_BUFFER_COUNT)\n\n// this is to thread multiple interval checkers in case of bouncy touchpads\n// again, global variable path is a terrible idea. I'm never doin this shit again.\n// I thought there would be no more than 5.\nvar intervalIDArray = new Array(COPY_MOUSE_ACTIVATION_CHECK_COUNT)\nvar timePassedArray = new Array(COPY_MOUSE_ACTIVATION_CHECK_COUNT)\nvar mouseDownBooleanArray = new Array(COPY_MOUSE_ACTIVATION_CHECK_COUNT)\nvar mouseHoldCount = MOUSE_HOLD_COUNT\n\nfor (var x = 0; x < COPY_MOUSE_ACTIVATION_CHECK_COUNT; x++) {\n  timePassedArray[x] = 0\n  mouseDownBooleanArray[x] = false\n  intervalIDArray[x] = []\n}\n\nvar fs = require('fs')\n// replace with logging library\n/*\nvar util = require('setAllTextArraysToDefault')\nvar log_file = fs.createWriteStream('./logs/debug.log', {\n  flags: 'w'\n})\n\nvar log_stdout = process.stdout\n\n//log.info = function (d) { //\n  log_file.write(util.format(d) + '\\n')\n  log_stdout.write(util.format(d) + '\\n')\n}\n*/\n// redirect stdout / stderr\n// constructor for mouse circular buffer\n\n// MOUSE BUFFER GLOBAL VARIABLES\nvar mouseCircularBuffer = new CircularBuffer(COPY_BUFFER_COUNT)\nmouseCircularBuffer.enq(clipboard.readText())\nvar mouseDown = false\n\nvar shortcutKeys = {}\nvar showKeyConfig = 'doodle'\nvar copyKeyConfig = 'quack'\n// initialize all the global Arrays\nfunction setAllTextArraysToDefault () {\n  var n = COPY_BUFFER_COUNT\n  for (var i = 0; i < n; ++i) {\n    textBufferTimer[i] = new Date()\n    textBufferChecker[i] = 0\n    textBufferFired[i] = false\n    textBufferContent[i] = '=('\n  }\n  var n = SHORTCUT_KEY_LIMIT\n  for (i = 0; i < n; ++i) {\n    shortcutKeys[i] = {}\n  }\n}\n\n// Or use `remote` from the renderer process.\n// const {BrowserWindow} = require('electron').remote\n\nvar mainWindow = null\nlet bufferWindow = null\nlet circularBufferWindow = null\nvar circularBufferWindowReady = false\nlet saveWindow = null\nlet showWindow = null\n// Load a remote URL\n\n/* This function shows the current window that is available\n */\n\n//\nlog.transports.file.level = 'info'\nlog.transports.file.format = '{h}:{i}:{s}:{ms} {text}'\n\n// Set approximate maximum log size in bytes. When it exceeds,\n// the archived log will be saved as the log.old.log file\nlog.transports.file.maxSize = 5 * 1024 * 1024\n\n// Write to this file, must be set before first logging\nlog.transports.file.file = path.join(__dirname, '/log.txt')\n\n// fs.createWriteStream options, must be set before first logging\n// you can find more information at\n// https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options\nlog.transports.file.streamConfig = { flags: 'w' }\n\n// set existed file stream\nlog.transports.file.stream = fs.createWriteStream('log.txt')\n\nfunction showBuffer () {\n  // TODO: Parameterize width and height\n  bufferWindow = new BrowserWindow({\n    width: 400,\n    height: 200,\n    transparent: false\n  })\n  bufferWindow.loadURL(`file://${__dirname}/resources/views/index.html`)\n  bufferWindow.webContents.on('did-finish-load', function () {\n    bufferWindow.webContents.send('load-buffer', readString)\n  })\n}\n\nfunction startCircularBufferWindow () {\n  circularBufferWindow = new BrowserWindow({\n    width: 400,\n    height: 200,\n    transparent: false\n  })\n\n  // YOU MIGHT ALSO HAVE TO CHANGE THIS LINE TO PREVENT THE FREEZE BUG\n  circularBufferWindow.loadURL(`file://${__dirname}/resources/views/mousebuffer.html`)\n  circularBufferWindow.show()\n\n  copyTimePassed = 0\n  circularBufferWindow.webContents.on('did-finish-load', function () {\n    pasteStarted = true\n    // this is to get that first buffer immediately\n    cycleBufferWindow()\n    copyMouseInterval = setInterval(function () {\n      cycleBufferWindow()\n    }, COPY_MOUSE_CYCLE_INTERVAL)\n    copyMouseIntervalStack.push(copyMouseInterval)\n    circularBufferWindowReady = true\n    // need to implement cycling logic there\n  })\n}\n\nfunction cycleBufferWindow () {\n  log.info('mousedownyyy')\n  if (mouseDown) {\n    copyTimePassed += COPY_MOUSE_CYCLE_INTERVAL\n    /// ///log.info('cycling choo choo')\n    copyMouseItemIdx++\n    if (copyMouseItemIdx >= mouseCircularBuffer.size() || copyMouseItemIdx == -1) {\n      copyMouseItemIdx = 0\n    }\n    // e, this is a hack. Probably need to completely redesign this feature to be more click based\n    // error: we have a race condition with circular buffer window - need to fix.\n    if (circularBufferWindow != null && circularBufferWindow.isDestroyed() && circularBufferWindowReady) {\n      circularBufferWindow.webContents.send('cycle-buffer', mouseCircularBuffer.get(copyMouseItemIdx))\n    }\n    /* I'm adding a delay here because there is a change that the message doesn't reach the display fast enough\n    then the code below wil execute and cause massive confusion because there's a disrepency with the view */\n  } else {\n    setTimeout(function () {\n      log.info('pasting')\n      pasteMouseCycleAndReset()\n    }, PASTE_DELAY)\n  }\n}\n\nfunction pasteFromCircularBuffer (circularBufferIdx) {\n  // this is pretty much a classic swaparoo in CS\n  log.info('paste from circular buffer')\n  var currentText = (' ' + clipboard.readText()).slice(1)\n  var textFromBuffer = mouseCircularBuffer.get(circularBufferIdx)\n  // need to add zero error handling - nothing inside\n  clipboard.writeText(textFromBuffer)\n  setTimeout(function () {\n    pasteCommand(currentText)\n  }, PASTE_DELAY)\n}\n\nfunction pasteMouseCycleAndReset () {\n  log.info('pasting started!')\n  copyTimePassed = 0\n\n  log.info('os' + OS)\n  if (OS == 'darwin') {\n    Menu.sendActionToFirstResponder('hide:')\n    if (circularBufferWindow != null) {\n      log.info('destroying started!')\n      circularBufferWindow.destroy()\n      circularBufferWindowReady = false\n    }\n  }\n  if (OS == 'win32') {\n    if (circularBufferWindow != null) {\n      log.info('destroying started')\n      circularBufferWindow.destroy()\n      circularBufferWindowReady = false\n    }\n  }\n  pasteFromCircularBuffer(copyMouseItemIdx)\n  pasteStarted = false\n  mouseDown = true\n  bufferCycling = false\n}\n\nfunction bufferKeyPressedWithModifier (event) {\n  // TODO: REFACTOR WHEN CONFIGURATION Is SET\n  /*\n    var keycode = event.keycode\n    if (keycode >= 2 && keycode <= 11 && event.ctrlKey === true) {\n      return true\n    }\n    return false\n    */\n  log.info(shortcutKeys)\n  ('Event key code' + event.keycode)\n  for (var sKey in shortcutKeys) {\n    var keyConfig = shortcutKeys[sKey]\n    log.info('shortcut key code' + keyConfig.keycode)\n    log.info('shortcut key code' + keyConfig)\n    if (event.keycode == keyConfig.keycode) {\n      var match = ensureModifierKeysMatch(event, keyConfig)\n      return match\n    }\n  }\n  return false\n}\n\nfunction ensureModifierKeysMatch (event, keyConfig) {\n  var modifiersToCheck = []\n  log.info(event)\n  for (var modifierKey in keyConfig) {\n    log.info('modifiers check')\n    log.info(modifierKey)\n\n    if (modifierKey != 'rawcode' && modifierKey != 'keycode') {\n      if (keyConfig[modifierKey]) {\n        modifiersToCheck.push(modifierKey)\n      }\n    }\n  }\n  log.info('modifiers to check' + modifiersToCheck)\n  for (var modIdx in modifiersToCheck) {\n    var modifier = modifiersToCheck[modIdx]\n    if (event[modifier] == false) {\n      return false\n    }\n  }\n  if (modifiersToCheck.length == 0) {\n    return false\n  }\n  return true\n}\n\nfunction showKeysTriggered (event, keyConfig) {\n  var modifiersToCheck = []\n  log.info(event)\n  for (var modifierKey in keyConfig) {\n    log.info('modifiers check')\n    log.info(modifierKey)\n\n    if (modifierKey != 'rawcode' && modifierKey != 'keycode') {\n      if (keyConfig[modifierKey]) {\n        modifiersToCheck.push(modifierKey)\n      }\n    }\n  }\n  log.info('modifiers to check' + modifiersToCheck)\n  for (var modIdx in modifiersToCheck) {\n    var modifier = modifiersToCheck[modIdx]\n    if (event[modifier] == false) {\n      return false\n    }\n  }\n  if (modifiersToCheck.length == 0) {\n    return false\n  }\n  if (modifiersToCheck.length < 2) {\n    return false\n  }\n  return true\n}\n/* The condition to hold down are relaxed here so that the user will have to hold\n  onto one button */\nfunction bufferKeyReleased (event) {\n  for (var sKey in shortcutKeys) {\n    if (event.keycode == shortcutKeys[sKey].keycode) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction triggerBuffer (bufferNum) {\n  textBufferTimer[bufferNum] = new Date()\n  textBufferFired[bufferNum] = true\n}\n\nfunction copyKeyTriggered (event) {\n  if (event.keycode == copyKeyConfig.keycode) {\n    var match = ensureModifierKeysMatch(event, copyKeyConfig)\n    return match\n  }\n}\n\n// Register and start hook\n\nfunction waitBeforeCyclingBuffer () {\n  // this can cause a bug, may have to contniously monitor to see that mouse has been held. Single check may screw up.\n\n  for (var x = 0; x < COPY_MOUSE_ACTIVATION_CHECK_COUNT; x++) {\n    timePassedArray[x] = 0\n    log.info('time pass init' + timePassedArray[x])\n  }\n  // since mouse clicks go up and down, the wait period might miss a few increments\n  // solution: create four interval ids. If one of them is true(set it in a ored variable), then it's triggered.\n  var interval = setInterval(function () {\n    mouseDownAccum++\n    console.log(mouseDownAccum)\n    if (mouseDown) {\n      if (mouseDownAccum > MOUSE_ACCUM_CAP) {\n        mouseDownAccum = MOUSE_ACCUM_CAP\n        if (!bufferCycling && circularBufferWindowReady) {\n          bufferCycling = true\n          startCircularBufferWindow()\n        }\n      }\n    } else {\n      mouseDownAccum--\n      mouseUpAccum--\n    }\n    if (mouseUpAccum <= 0) {\n      clearInterval(interval)\n      mouseUpAccum = MOUSE_UP_COUNT\n      mouseDownAccum = 100\n    }\n  }, MOUSE_CHECK_TIME)\n}\n\n// effectively a delta to ensure that there isn't a single mousedown checkpoint of failure\n\nfunction saveBuffer (bufferNum) {\n  var currentText = (' ' + clipboard.readText()).slice(1)\n  log.info('buff num:' + bufferNum + ' currentText:' + currentText)\n  textBufferChecker[bufferNum] = 1\n  textBufferTimer[bufferNum] = new Date()\n  // this also needs to be externalized\n\n  setTimeout(function () {\n    robotCopyDelay(bufferNum)\n  }, 100)\n}\n\nfunction robotCopyDelay (bufferNum) {\n  robot.keyTap('c', ['command'])\n  setTimeout(function () {\n    anotherContext(bufferNum)\n  }, 100)\n}\n\nfunction anotherContext (bufferNum) {\n  textBufferContent[bufferNum] = (' ' + clipboard.readText()).slice(1)\n  clipboard.writeText(textBufferContent[bufferNum])\n}\n\nfunction pasteBuffer (bufferNum) {\n  // this is pretty much a classic swaparoo in CS\n  if (textBufferChecker[bufferNum] === 1) {\n    // WATCH OUT FOR THIS FUCKING LINE\n    log.info('buffer checker is set')\n    var currentText = (' ' + clipboard.readText()).slice(1)\n    var textFromBuffer = textBufferContent[bufferNum]\n    log.info(textBufferContent)\n    clipboard.writeText(textFromBuffer)\n    setTimeout(function () {\n      pasteCommand(currentText)\n    }, PASTE_DELAY)\n  }\n}\n\nfunction pasteCommand (currentText) {\n  // all the stuff you want to happen after that pause\n  robot.keyTap('v', ['command'])\n  log.info('is this a reference to a pointer?' + clipboard.readText())\n  log.info('paste command pressed')\n  setTimeout(function () {\n    log.info('currenttext:' + currentText)\n    clipboard.writeText(currentText)\n  }, PASTE_DELAY)\n}\n\nfunction setGlobalShortcuts () {\n  globalShortcut.unregisterAll()\n  const os = process.platform\n  var shortcutConfig = configuration.readSettings(os)\n  var i = 0\n  for (var key in shortcutConfig) {\n    if (key == 'copyKey') {\n      copyKeyConfig = shortcutConfig[key]\n      log.info(copyKeyConfig)\n    } else if (key == 'showKey') {\n      showKeyConfig = shortcutConfig[key]\n      // log.info(showKeyConfig)\n    } else {\n      shortcutKeys[key] = shortcutConfig[key]\n    }\n  }\n  // you need to loop afterwards\n  /*\n      globalShortcut.register(shortcutKeySetting1, function () {\n        mainWindow.webContents.send('global-shortcut', 0)\n      })\n      */\n  // pop up paste buffer\n  // var nRegistered = globalShortcut.isRegistered('n')\n\n  /*\n      globalShortcut.register('n', function () {\n        // showBuffer()\n        for (var item in mouseCircularBuffer) {\n          //log.info(item)\n        }\n      })\n      globalShortcut.register('m', function () {\n        bufferWindow.webContents.send('inc-opq', readString)\n      }) */\n}\n\n// iohook setup\n\nfunction restoreSaveState () {\n\n}\n\napp.on('ready', () => {\n  // need to externalize window size\n  // log.info(__dirname)\n  mainWindow = new BrowserWindow({\n    width: 800,\n    height: 600,\n    focusable: false,\n    icon: path.join(__dirname, 'assets/quickclip.png')\n  })\n  mainWindow.on('closed', () => {\n    mainWindow = null\n    bufferWindow = null\n    globalShortcut.unregisterAll()\n    app.quit()\n  })\n\n  mainWindow.on('minimize', function (event) {\n    event.preventDefault()\n    mainWindow.hide()\n  })\n  mainWindow.on('defocus', function (event) {\n    // log.info('da focused')\n    mainWindow.hide()\n  })\n  // I'm scared this will cause an infinite loop with above\n  mainWindow.on('hide', function (event) {\n    // log.info('hidden')\n    mainWindow.hide()\n  })\n\n  mainWindow.loadURL(`file://${__dirname}/resources/views/index.html`)\n  // log.info(__dirname)\n\n  saveWindow = new BrowserWindow({\n    width: 250,\n    height: 200,\n    focusable: false\n  })\n  saveWindow.on('minimize', function (event) {\n    event.preventDefault()\n    saveWindow.hide()\n  })\n  saveWindow.on('defocus', function (event) {\n    // log.info('da focused')\n    saveWindow.hide()\n  })\n  // I'm scared this will cause an infinite loop with above\n  saveWindow.on('hide', function (event) {\n    // log.info('hidden')\n    saveWindow.hide()\n  })\n\n  saveWindow.loadURL(`file://${__dirname}/resources/views/savepop.html`)\n  saveWindow.hide()\n  // load circular buffer from save.json\n  var circularBufferFromConfig = stateSaver.readValue('circularBuffer')\n  // log.info(circularBufferFromConfig)\n\n  var text = mouseCircularBuffer.deq()\n  for (var x = circularBufferFromConfig.length - 1; x >= 0; x--) {\n    // if you save 1 2 3 , you need to load 3 2 1\n    mouseCircularBuffer.enq(circularBufferFromConfig[x])\n  }\n  mouseCircularBuffer.enq(text)\n  // load key values from save.json\n  setAllTextArraysToDefault()\n  var keyBufferFromConfig = stateSaver.readValue('keyBuffer')\n  // log.info(keyBufferFromConfig)\n  for (var key in keyBufferFromConfig) {\n    if (keyBufferFromConfig.hasOwnProperty(key)) {\n      var bufferNumber = key\n      textBufferContent[bufferNumber] = keyBufferFromConfig[bufferNumber]\n      if (textBufferContent[bufferNumber] != '=(') {\n        textBufferChecker[bufferNumber] = 1\n      }\n      textBufferTimer[bufferNumber] = new Date()\n      // log.info(bufferNumber + ' -> ' + textBufferContent[bufferNumber])\n    }\n  }\n\n  /*\n  //log.info(mouseCircularBuffer.size())\n  for (var x = 0; x < mouseCircularBuffer.size(); x++) {\n    // if you save 1 2 3 , you need to load 3 2 1\n    //log.info(mouseCircularBuffer.get(x))\n  } */\n\n  // REMOVE THIS LATER: mainWindow.hide()\n  // let win = new BrowserWindow({transparent: true, frame: false})\n  // win.show()\n\n  // IMPORTANT NOTE: NCONFG IS SAVED\n  setGlobalShortcuts()\n  ioHook.start()\n})\n\napp.on('before-quit', () => {\n  stateSaver.saveValue('circularBuffer', mouseCircularBuffer.toarray())\n  var saveObj = {}\n  for (var x = 0; x < textBufferContent.length; x++) {\n    saveObj[x] = textBufferContent[x]\n  }\n  stateSaver.saveValue('keyBuffer', saveObj)\n  ioHook.unload()\n  ioHook.stop()\n})\n\nipcMain.on('close-main-window', function () {\n  app.quit()\n})\n\nioHook.on('mouseup', event => {\n  var pasteDateDiff = Math.abs(lastPressTime - new Date())\n\n  if (pasteStarted && mouseDown && pasteDateDiff > 4000) {\n    lastPressTime = new Date()\n    console.log('laste paste time' + lastPressTime)\n    // DO NOT REMOVE THIS LINE! IF YOU DO, YOU'LL HAVE CONCURRENCY ISSUES\n    pasteStarted = false\n    pasteMouseCycleAndReset()\n    log.info('possibly global variable clearning is an issue?')\n    clearInterval(copyMouseInterval)\n    while (copyMouseIntervalStack.length > 0) {\n      clearInterval(copyMouseIntervalStack.pop())\n    }\n  }\n  mouseDown = false\n  pasteStarted = false\n})\nioHook.on('keydown', event => {\n  var number = keyMapper.getKeyFromCode(event.keycode)\n  // keycode 46 is control c\n  if (bufferKeyPressedWithModifier(event)) {\n    // log.info('detected!')\n    if (textBufferFired[number] == false) {\n      // log.info('text buffer triggered!')\n      triggerBuffer(number)\n    }\n    var lastKeyDownDate = textBufferTimer[number]\n    // log.info('goot time to save')\n    var diff = Math.abs(new Date() - lastKeyDownDate)\n    var saveTimeObj = {}\n    if (!saveWindowHiding) {\n      saveWindow.show()\n      saveWindowHiding = false\n    }\n    if (diff > COPY_BUFFER_TIME) {\n      saveTimeObj.save = 'Savable'\n      saveTimeObj.time = String((diff / 1000).toPrecision(3)) + 'seconds'\n      saveWindow.webContents.send('load-state-time', saveTimeObj)\n      saveWindow.show()\n    } else {\n      saveTimeObj = {}\n      saveTimeObj.save = 'Unsavable'\n      saveTimeObj.time = String((diff / 1000).toPrecision(3)) + 'seconds'\n      saveWindow.webContents.send('load-state-time', saveTimeObj)\n      saveWindow.show()\n    }\n  }\n  if (copyKeyTriggered(event)) {\n    // this is an arificial delay for robotjs and os to register cmd + x\n    setTimeout(function () {\n      var text = clipboard.readText()\n      // log.info('herro')\n      // log.info(text)\n      mouseCircularBuffer.enq(text)\n    }, 100)\n  }\n  if (showKeysTriggered(event, showKeyConfig)) {\n    // this is an arificial delay for robotjs and os to register cmd + x\n    console.log('show me monies')\n    if (showOrHideShowWindow) {\n      if (showWindow == null) {\n        loadShowWindow()\n      } else {\n        showWindow.show()\n      }\n\n      showOrHideShowWindow = !showOrHideShowWindow\n      setTimeout(function () {\n        var textObj = {}\n        textObj.textBufferTimer = textBufferTimer\n        textObj.textBufferChecker = textBufferChecker\n        textObj.textBufferFired = textBufferFired\n        textObj.textBufferContent = textBufferContent\n        showWindow.webContents.send('load-buffer', textObj)\n      }, 500)\n    } else {\n      if (showWindow != null) {\n        showWindow.close()\n        showOrHideShowWindow = !showOrHideShowWindow\n      }\n    }\n  }\n})\n\nfunction loadShowWindow () {\n  showWindow = new BrowserWindow({\n    width: 400,\n    height: 800,\n    focusable: false\n  })\n  showWindow.on('minimize', function (event) {\n    event.preventDefault()\n    saveWindow.hide()\n  })\n  showWindow.on('defocus', function (event) {\n    // log.info('da focused')\n    saveWindow.hide()\n  })\n  // I'm scared this will cause an infinite loop with above\n  showWindow.on('hide', function (event) {\n    // log.info('hidden')\n    saveWindow.hide()\n  })\n\n  showWindow.on('close', function (event) {\n    // log.info('hidden')\n    saveWindow.destroy()\n    showWindow = null\n  })\n  showWindow.loadURL(`file://${__dirname}/resources/views/show.html`)\n}\n\nioHook.on('keyup', event => {\n  if (bufferKeyReleased(event)) {\n    // log.info('buffer key released')\n    var number = keyMapper.getKeyFromCode(event.keycode)\n    if (textBufferFired[number] === true) {\n      var curDate = new Date()\n      var lastKeyDownDate = textBufferTimer[number]\n      // log.info('time diff')\n      var diff = Math.abs(new Date() - lastKeyDownDate)\n      // log.info(lastKeyDownDate.toString())\n      // log.info(curDate.toString())\n      // log.info(diff)\n      // log.info(textBufferContent)\n      if (diff < COPY_BUFFER_TIME) {\n        saveWindow.hide()\n        Menu.sendActionToFirstResponder('hide:')\n        pasteBuffer(number)\n      } else {\n        saveWindow.hide()\n        Menu.sendActionToFirstResponder('hide:')\n        // Menu.sendActionToFirstResponder('hide:')\n        saveBuffer(number)\n      }\n      textBufferFired[number] = false\n    }\n  }\n})\n\nioHook.on('mousedown', event => {\n  currentEvent = event\n  // log.info(event)\n  // this is prety much a mutex\n  if (!pasteStarted && !mouseDown) {\n    mouseDown = true // I'm downing the mouse twice so the computer doesn't enter the critical section twice\n    log.info('initiate buffer cycling!')\n    waitBeforeCyclingBuffer()\n  }\n  mouseDown = true\n  lastPressTime = new Date()\n\n  // remember to add mainwindow = null later.\n})",
    "en(",
    "en(",
    "lisa_dir = './data/LISA_TS_EXT/annotations/'",
    "lisa_dir = './data/LISA_TS_EXT/annotations/'",
    "    lastePressTime = new Date()"
  ],
  "keyBuffer": {
    "0": "=(",
    "1": "https://github.com/jupyter/notebook/issues/2844",
    "2": "=(",
    "3": "https://stackoverflow.com/questions/18588133/fastest-way-to-test-two-strings-for-exact-match-in-javascript",
    "4": "=(",
    "5": "=(",
    "6": "=(",
    "7": "=(",
    "8": "=(",
    "9": "=("
  }
}