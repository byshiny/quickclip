{
  "comment": "I'm trying to keep format consistent, so I'm going to have",
  "circularBuffer": [
    "void timer_handler (int signum)\n{\n static int count = 0;\n printf (\"timer expired %d times\\n\", ++count);\n}",
    "void timer_handler (int signum)\n{\n static int count = 0;\n printf (\"timer expired %d times\\n\", ++count);\n}",
    "void timer_handler (int signum)\n{\n static int count = 0;\n printf (\"timer expired %d times\\n\", ++count);\n}",
    "void timer_handler (int signum)\n{\n static int count = 0;\n printf (\"timer expired %d times\\n\", ++count);\n}",
    " struct sigaction sa;\n struct itimerval timer;\n\n /* Install timer_handler as the signal handler for SIGVTALRM. */\n memset (&sa, 0, sizeof (sa));\n sa.sa_handler = &timer_handler;\n sigaction (SIGVTALRM, &sa, NULL);\n\n /* Configure the timer to expire after 250 msec... */\n timer.it_value.tv_sec = 0;\n timer.it_value.tv_usec = 250000;\n /* ... and every 250 msec after that. */\n timer.it_interval.tv_sec = 0;\n timer.it_interval.tv_usec = 250000;\n /* Start a virtual timer. It counts down whenever this process is\n   executing. */\n setitimer (ITIMER_VIRTUAL, &timer, NULL);\n\n /* Do busy work. */\n while (1);",
    "static int count = 0;\n printf (\"timer expired %d times\\n\", ++count);",
    "ttp://www.informit.com/articles/article.aspx?p=23618&seqNum=14",
    "        char buf[100];\n        char *str = NULL;\n        char *temp = NULL;\n        unsigned int size = 1; // start with size of 1 to make room for null terminator\n        unsigned int strlength;\n\n        FILE *fp;\n        char path[1035];\n\n        /* Open the command for reading. */\n        //fp = popen(\"/bin/ls /etc/\", \"r\");\n        fp = popen(\"pwd\", \"r\");\n        if (fp == NULL) {\n                printf(\"Failed to run command\\n\" );\n                exit(1);\n        }\n\n        /* Read the output a line at a time - output it. */\n        while (fgets(path, sizeof(path)-1, fp) != NULL) {\n                printf(\"%s\", path);\n        }\n        \n        /* close */\n        pclose(fp);\n        printf(\"Hello, World\\n\"); // \\n indicates a newline character\n\n        //need this command to contniously run, probably look for quit messages\n        scanf(\"%s\", quit);\n",
    "Advanced Linux Programming",
    "void timer_handler (int signum)\n{\n static int count = 0;\n printf (\"timer expired %d times\\n\", ++count);\n}"
  ],
  "keyBuffer": {
    "0": "=(",
    "1": "http://www.informit.com/articles/article.aspx?p=23618&seqNum=14",
    "2": "#include <sys/mman.h>",
    "3": "https://stackoverflow.com/questions/5656530/how-to-use-shared-memory-with-linux-in-c",
    "4": "=(",
    "5": "=(",
    "6": "=(",
    "7": "=(",
    "8": "=(",
    "9": "=("
  }
}